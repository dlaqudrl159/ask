자바 면접 질문

Q. java란

A. 자바란 객체지향 프로그래밍 언어 입니다.

Q. java의 특징

A. 

장점

JVM(자바 가상 머신) 위에서 동작해 운영 체제에 독립적 입니다.
GC(가비지 컬렉터)를 통한 자동적인 메모리 관리 기능이 있습니다.
쓰레드 생성 및 제어와 관련된 API를 제공해 멀티 쓰레드 구현이 쉽습니다.
동적로딩을 지원합니다 실행시 모든 클래스가 실행되는것이 아닌 
필요한 시점에 클래스를 로딩 합니다.

단점

JVM(자바 가상 머신)을 거쳐 실행하기에 상대적으로 속도가 느립니다.
자바는 예외 처리를 일일이 처리해 줘야 합니다.
 
Q. JVM이란?

A. JVM이란 자바 가상 머신으로 자바의 바이트 코드를 운영체제에 맞게 해석해줍니다.
   또 GC(가비지 컬렉터)를 통해 자동적인 메모리 관리를 해줍니다.

Q. 바이트 코드란?

A. 가상 컴퓨터 에서 돌아가는 실행프로그램을 위한 이진 표현법입니다.
    자바 바이트 코드는 JVM이 이해 할 수 있는 언어로 변환된 자바 소스 코드 입니다.
    바이트 코드는 다시 JIT컴파일러에 의해 바이너리 코드로 변환됩니다.

Q. JIT 컴파일러란?
A. 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일러 입니다.
    인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 하여
    기계어로 변경하고 이후에는 더 이상 인터프리팅 하지 않고 기계어로 직접 실행하는 방식
    (처음 실행 될 때 인터프리트를 하다가 자주 쓰는 코드를 캐싱한 뒤 이후에는 캐싱된 코드를
     가져다 쓰는 경우)

Q. 인터프리터란?
A. 고급 언어로 작성된 프로그램을 한 줄 단위로 번역하고 번역과 동시에 프로그램을 즉시 실행 시키는 방식
    인터프리터는 실행 시마다 소스 코드를 한 줄씩 기계어로 번역하는 방식이기 때문에
    실행 속도가 느립니다. 그래서 JIT컴파일러에 인터프리터를 내장해 쓰는 방식이 도입되었습니다.

* 자바는 인터프리터와 컴파일 방식이 혼합된 언어입니다.
   인터프리터로 작동하다가(한줄씩 기계어로 번역)하다가 자주쓰이는 코드를 인식해 
   그 코드를 JIT컴파일러가 컴파일하여 기계어로 직접 실행합니다.

Q. JVM 구성요소

A. 클래스 로더 , 실행 엔진, 인터프리터 , JIT컴파일러 , 가비지 콜렉터 , 런타임 데이터 영역

Q. 클래스 로더란?

A. JVM내로 클래스(.class) 파일을 로드하고 링크를 통해 배치하는 작업을 수행하는 모듈입니다.

Q. 실행 엔진이란?

A. 클래스를 실행시키는 역할입니다. 클래스로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고
    이것은 실행 엔진에 의해 실행 됩니다.
    자바 바이트 코드를 JVM내부에서 기계가 실행할 수 있는 형태로 변경합니다.

Q. GC(가비지 컬렉터)란?

A. JVM위에서 작동하며 유효하지 않은 메모리(Garbage)를 자동으로 정리해줍니다.


Q. GC(가비지 컬렉터)의 과정을 설명해 주세요

A. 먼저 JVM의 애플리케이션의 실행을 중단합니다. 이를 Stop The World 라고 부릅니다.
    GC의 실행 쓰레드를 제외한 모든 쓰레드를 중단합니다.
    그리고 Mark and Sweap 작업을 실시합니다. Stack 영역에 변수와 Reachable 오브젝트가
    참조하고 있는 오브젝트를 찾아 marking을 합니다. 그리고 marking이 되어 있지 않은 
    모든 오브젝트들을 Heap 영역에서 제거합니다. 이를 Sweap이라고 부릅니다.
    GC의 작업은 Young영역에 대한 Minor GC와 Old영역에 대한 Major GC 로 구분 됩니다.

Q. Young영역과 Old영역에 대해 설명해 주세요

A. Heap영역을 객체의 생존기간에 따라 나눈 영역입니다.
   Young영역은 새롭게 생성된 객체가 할당 되는 영역입니다.
   대부분 객체는 Unreachable 상태가 되기 때문에 많은 객체가 Young영역에 저장됩니다.
   Old영역은 Reachable 상태를 유지하며 살아남은 객체가 복사되는 영역입니다.
   Young영역보다 큽니다. 수명이 짧은 객체들은 큰 영역을 필요하지 않고
   큰 객체들은 바로 Old영역에 할당 됩니다.

Q. 카드 테이블에 대해 설명해주세요

A. 카드 테이블이란 Old영역에 있는 객체가 Young영역의 객체를 참조할 때 정보를 표시해 줍니다.
    Young영역에 가비지가 실행 될 때 Old 영역을 탐색하는것은 비효율적입니다.
    그래서 카드 테이블만 조회하여 GC의 대상인지 식별하는 역할을 합니다.

Q. Minor GC와 Major GC에 대해 설명해 주세요

A. Minor GC는 Young영역에서 이뤄지는 가비지 컬렉터 입니다.
   먼저 Young영역은 1개의 Eden 영역과 2개의 Survior영역으로 나뉘어져 있습니다.
   Eden 영역 : 새로 생성된 객체가 할당 되는 영역
   Survior 영역 : 최소 1번의 GC에서 살아남은 객체가 존재하는 영역
   먼저 Eden영역이 꽉차면 Minor GC가 실행됩니다. 살아남은 객체는 Surivior영역을 이동됩니다.
   Suivior영역은 2곳으로 한가지 영역은 비어있어야 합니다. 
   Minor GC가 실행될 때마다 Survior1영역에 살아남은 객체는 Survior2영역으로 이동 됩니다.
   (다음 Minor GC 실행시 2 > 1 로 이동 이러한 과정 반복)
   살아남은 객체는 Minor GC 실행시 나이가 먹는데 설정된 나이가 넘으면 Old영역으로 이동됩니다.

   Major GC 는 Old 영역에서 메모리가 가득차면 Major GC가 실행 되며
   Minor GC 에 비해 많은 시간이 걸립니다.

Q. Runtime Data Area에 대해 설명해 주세요

A. 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간 입니다.

Q. 자바의 메모리 구조에대해 설명해 주세요

A. 자바의 메모리 구조는 크게 3가지로 구분 됩니다.
    Method 영역 Heap 영역 Stack 영역 으로 구분 됩니다.
    Method 영역은 전역변수나 static변수

    Method 영역은 각종 필드의 정보들과 메서드 정보 static변수 final class 등이 생성되는 영역입니다
    프로그램 시작부터 종료까지 남아있습니다.
    Heap 영역은 new 키워드로 생성되는 객체 그리고 배열들이 생성되는 영역입니다.
    가비지 컬렉터를 통한 메모리 관리를 받습니다.
    Stack영역은 지역 변수 매개 변수 메서드 등이 할당되는 영역입니다.
    LIFO방식(Last In First Out)의 구조를 가지고 있습니다.
메서드영역 jvm이 동작해서 클래스가 로딩될때

Q. 필드가 뭐예요?

A. 객체의 고유 데이터. 객체의 현재 상태를 저장하는 곳 입니다.

Q. 변수가 뭐예요?

A. 하나의 값을 저장할 수 있는 메모리 공간입니다.

Q. 상수가 뭐예요?

A. 한 번만 값을 저장 가능한 변수 입니다. final 이라는 키워드를 붙여 생성합니다.

Q. 메서드가 뭐예요?

A. 객체의 기능을 정의해놓은것 입니다.

Q. static변수가 뭐예요?

A. static변수란 객체생성없이 사용할 수 있는 변수이며 클래스 로딩시 바로 사용 가능합니다.
    인스턴스가 공통적인 값이 유지되어야 하는 경우 static을 붙입니다.
    static이 붙은 변수는 method영역에 존재하여 클래스 로딩시 바로 생성되어서 객체 생성
    없이도 사용 가능합니다.

Q. 인스턴스가 뭐예요?

A. 인스턴스는 객체를 생성시 메모리상에 올라가 생성된 객체를 의미합니다.
    예를 들어 붕어빵이란 객체를 생성했을때 A붕어빵 인스턴스가 되고
    또 생성시 B붕어빵 인스턴스가 됩니다.

Q. 클래스가 뭐예요?

A. 클래스란 자바 프로그램의 실행 단위 입니다.
    객체를 생성하기 위한 설계도로 객체의 필드(속성) 기능(메서드)를 정의하고 있습니다.

Q. 객체란 말이 자주 나오는데 객체가 뭔가요?

A. 데이터의 분산화를 막기 위한 데이터와 기능의 묶음입니다.

Q. 객체 지향 프로그래밍이 뭔가요?

A. 객체지향 프로그래밍이란 모든 데이터를 객체로 취급하며 생성된 객체끼리 상호작용을 통해
    프로그램이 동작하게 하는 프로그래밍 기법입니다.

Q. 객체 지향 프로그래밍의 장점이 뭔가요?

A. 남이 만든 코드를 가져와서 이용할 수 있고 상속을 통해 코드의 재사용성을 높일 수 있다.
    클래스 단위로 모듈화 시켜 개발 할 수 있으므로 업무 분담이 쉽습니다.
    프로그램 수정시 캡슐화를 통해 주변 영향이 적기 때문에(결합도가 낮다) 유지보수가 쉽습니다.
    
Q. 객체 지향 프로그래밍의 단점이 뭔가요?

A. 객체들을 나눠서 설계해야하니 설계시 시간이 오래 걸립니다.
    절차지향언어에 비해 상대적으로 느립니다.


Q. 왜 절차지향언어에 비해 느린가요?
 자바는 클래스단위로 모든 코드를 작성하는데 클래스에 있는 일부 메서드나 정보를 사용하기
     위해서는 전체 클래스를 인스턴스로 만들어 메모리에 저장해야합니다. 
     (이런 문제를 해결하기위해 static을 사용하는 방법이 있으나 권장하는 방식은 아님) 
     그만큼 메모리를 많이 사용하게 되고 코드를 찾아서 로드하는 시간도 추가됩니다. 
     (만약 이런문제를 해결하기 위해 클래스 단위를 잘게 쪼개서 작성하면 객체를 다루는 효용성이 떨어짐
     필연적인 상황!!)
     이미 만들어진 클래스를 가져다 쓰는 일이 많으니 코드도 그만큼 많아짐 상속을 통해 재사용성이
     올라간다지만 인스턴스를 만들때 상속받는 메서드나 필드도 인스턴스 안에 포함되니깐!!
     이러한 이유로 자바는 동적 할당 방식을 사용함 

jvm 사용으로 인한 느림
자바는 먼저 바이트 코드로 컴파일 한 뒤 동적할당된 코드를 jvm의 실행엔진이 번역해서 실행합니다.
jit같은 방식으로 속도를 높였지만 c언에 비해 상대적으로 느립니다.
자바는 jvm이라는 하나의 프로그램 안에서 프로그램이 실행되니 2개 이상의 프로그램이 동시에 실행되어
메모리 사용과 연산이 많아지고 상대적으로 느릴 수 밖에 없습니다.
    
또한 자바는 가비지 컬렉터에 의해 메모리가 해제 되는데 가비지컬렉터 또한 프로그램이므로 메모리와
연산 작업을 동반합니다.

Q. 객체지향 프로그래밍의 특징이 뭔가요?

A. 객체지향 프로그래밍의 특징은 캡슐화, 상속, 다형성, 추상화 등이 있습니다.

Q. 캡슐화가 뭔가요?

A. 캡슐화란 클래스의 내부 변수와 메서드를 하나로 묶고 실제 구현 내부를 은닉하는 것 입니다.
    캡슐화를 사용하는 이유는 요구사항이 새롭게 추가되거나 변경되어도 클래스 내부의 변경만을 통해
    코드의 중복을 최소화하고 유지보수를 쉽게하기위함입니다. 데이터를 처리하는 방식을
    외부에 드러나지 않게 하고 객체 내부에서 처리하게 합니다.

Q. 접근 제한자란 뭔가요?

A. 외부에서 클래스의 멤버에 함부로 접근하지 못하게 제한을 거는 것 입니다.
   객체의 캡슐화를 지키고 데이터가 손상되는 것을 방지해 줍니다.
    private 같은 클래스내에서 접근 가능
    default 같은 패키지 내에서 접근 가능
    protected 같은 패키지 그리고 상속받는 클래스에서 접근가능
    public 접근 제한 없음

Q. 추상화란 뭔가요?

A. 불필요한 정보는 숨기고 공통된 속성이나 기능을 묶어 이름을 붙이는 것 입니다.
    코드의 유연함과 유지보수를 쉽게하는 장점이 있습니다.
    여러 객체들간의 공통적인 특징을 묶어놨기에 추상화된 클래스를
    상위 클래스로 두고 하위 클래스에는 공통된 속성이나 기능을 확장함으로써 
    코드의 유연함을 얻을 수 있습니다. 
    또 공통된 특징을 가지고 있기에 직관적입니다. 이 클래스가 무엇을 의미하는지 유추가 가능합니다.

Q. 다형성이란 뭔가요?

A. 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.
    부모클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있습니다.
    또 오버로딩과 오버라이딩을 통해 코드의 중복을 방지하고 개발 편의성을 높여줍니다.
    객체들 사이의 대체 가능성을 의미하여 설계와 프로그램을 유연하고 재사용 가능하게 만드는 행위
Q. 오버로딩이 뭔가요?
    한 클래스내에 이름이 같은 메서드가 허용되는 정책 입니다.
    메서드의 매개변수의 타입, 개수 배치 순서가 다르면 이름이 같은 메서드가 허용 됩니다.
    장점은 같은 기능을 하는 메서드를 하나의 이름으로 통일할 수 있습니다.
    메서드의 이름을 절약할 수 있습니다.

Q. 오버라이딩이 뭔가요?

A. 오버라이딩이란 자식클래스가 부모클래스의 메서드를 재정의 하는 것 입니다.
    물려받은 메서드가 자식클래스에서는 기능을 다르게 작동할 필요가 있을 때 씁니다.
    코드의 재사용성이 가능합니다.    

Q. 상속이란 뭔가요?
    
A. 상속이란 부모클래스의 필드와 메소드를 물려받아 자식 클래스에서 사용하는 것입니다.
    상위 클래스의 멤버를 물려받아 코드의 재사용성이 좋고 코드의 중복을 제거하여
    프로그램의 생산성과 유지보수에 크게 기여합니다.

Q. 추상클래스란 뭔가요?

A. 하나 이상의 추상 메서드를 포함하는 클래스를 추상클래스라고 합니다.
   실체 클래스에서 공통적인 부분만을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스입니다.

Q. 추상클래스는 왜 쓰나요?

A. 공통적인 필드와 메서드를 통일할 목적입니다.
   상속받는 클래스는 추상클래스의 필드와 메서드명을 변경할 수 없고 무조건 추상클래스의
   정의된 것과 똑같이 구현해야 합니다. 이로 인해 유지보수를 높이고 통일성을 높일 수 있습니다.

   클래스 구현시 시간이 절약되며 규격을 정할 수 있습니다.
   미리 정의해놓은 추상클래스를 토대로 서브클래스에서 코드를 작성하므로
   정해진 규격안에서 구현부만 작성하면 됩니다.
   
Q. 인터페이스는 뭔가요?

A. 클래스에서 특정 메서드를 강제로 구현하도록 하는 기능입니다.
   상수와 추상메서드의 집합
   
Q 인터페이스는 왜 쓰나요?
   1. 자바는 단일상속을 지원하는데 인터페이스는 다중 상속을 지원합니다.
      만약 각각 다른 추상클래스를 상속하는데 공통된 기능이 필요하다면 인터페이스를 활용

   2. 구현 객체가 같은 동작을 보장하기 위해 사용합니다.
      인터페이스를 구현하는 객체들은 강제로 메서드를 구현하면서 기본틀을 잡을수 있습니다.
   
   3. 관계없는 클래스들 끼리의 관계형성이 가능합니다.
      
Q. 자바에서는 왜 단일상속을 지원하나요?

A. 메소드의 모호성 때문입니다.
    2개의 클래스를 상속받을 때 만약 물려 받는 메소드가 같다면 어떤 메소드를 실행해야
   되는지 모르기 때문입니다.  

Q. 추상메서드란 뭔가요?
 
A. 클래스앞에 abstract이란 키워드가 붙으면 메소드가 선언만 되어있고 구현은 없는 메소드입니다.

Q. 내부클래스란 뭔가요?

A. 클래스안에 멤버로 들어있는 클래스입니다.

Q. 내부클래스의 장점이 뭔가요?

A. 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다. 
    (객체생성 없이도 멤버에 접근가능)
    코드의 복잡성을 줄일 수 있다(캡슐화)

Q. 내부 클래스의 종류에 대해 설명해주세요

A. 내부클래스는 인스턴스클래스 static클래스 지역클래스 익명클래스가 있습니다.

Q. 자바의 오류 종류

A. 컴파일 에러, 런타임 에러, 논리적 에러

컴파일에러 class파일이 만들어지지 않음

런타임에러 실행할 때 발생하는 에러

Q. 자바에서 정의한 런타임 에러는?

A. 에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
   예외 : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

Q. 예외처리의 목적은?

A. 프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지하는 것

Q. Exception과 RuntimeException이란

Exception : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외

RuntimeException 프로그래머의 실수로 발생하는 예외

Q. checked예외와 unchecked예외는 뭔가요? 

A.
checked예외 : 컴파일러가 예외 처리 여부를 체크(예외 처리 필수) Exception클래스와 그 자손
unchecked예외 : 컴파일러가 예외 처리 여부를 체크 안함(예외 처리 필수 아님) RuntimeException클래스와 그 자손
     
Q. equals 메서드는 뭔가요?

A. 객체의 주소값을 비교해서 같은 객체인지 아닌지 판단해줍니다.
    보통 오버라이딩해서 사용합니다.(iv값을 비교)오버라이딩 전에는 instanceof 메서드를 사용해 형변환이
    가능한지 체크해야합니다. 주소가 달라도 값을 비교해 true fals여부를 학인해 줍니다.

Q. hashcode 메서드는 뭔가요?

A. hashcode = 정수값 해싱 알고리즘 사용
    native메서드의 메서드를 사용해 객체의 주소값을 int로 반환해줌
    객체마다 다른값을 가지고 있음.
Q. 네이티브 메서드란 뭔가요?

A. OS의 메서드(주로 C언어로 작성)  

Q. equals()를 오버라이딩 하면 hashCode()를 오버라이딩 해야 합니다. 왜 그럴까요?

A. equals는 객체의 iv값을 가지고 true false를 판단하고 true라면 hashcode도 iv를 가지고 작업을 해서 두 주소가 같아야한다.
    둘다 주소를 가지고 작업을 함.
     equals는 iv값을 가지고 true flase 를 판단하고 hashcode도 iv를 가지고 작업을 해서 주소값을 반환해야 한다.

* 참고로 32bit jvm은 주소값이 int임 64bit jvm은 주소값이 long임
   hashcode의 타입은 int형인데 64bit jvm은 8byte임 그래서 long형을 int형으로 변환할때 주소값이 겹치는 값이 나올 수도 있음
   

Q. tostring메서드는 뭔가요?

A. 객체를 문자열로 변환하는 메서드 입니다.
    getClass().getName()+"@"+Integer.thHexString(hashCode());

* object클래스의 tostring은 별로 쓸모가없음 그래서 보통 오버라이딩을 이용해서 사용
   객체는 iv의 집합입니다. iv를 문자열로 바꿔서 보여줘야함
   
Q. 제네릭스란 뭔가요?

A. 컴파일시 타입을 체크해 주는 기능      
    객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌
* 제네릭스 타입이 생겨난이유 실행 중 에러(classcastexception)를 줄이기 위해 
  컴파일시 타입체크를 해서 에러를 줄여줌

Q. 타입 변수란 뭔가요?

A. 클래스를 작성할 때 object대신 타입변수(E)를 사용

Q. 제네릭스의 제약 사항이 뭔가요?

A. static멤버에 타입 변수 사용 불가
    배열 생성할 때 타입 변수 사용 불가 타입 변수로 배열 선언은 가능

Q. 열거형이란 뭔가요?

A. 관련된 상수들을 같이 묶어 놓은 것 입니다.
    자동으로 0 부터 매겨짐

c언어는 값만 체크하지만 자바는 값과 타입도 체크함
열거형 상수에 비교연산자 사용 불가 (<, >) 왜? 열거형 상수는 객체라서
compareto메서드 사용해야함

Q. OS스케줄러란 뭔가요?

A. 쓰레드의 실행 순서를 결정합니다.

Q. start메서드가 하는일은 뭔가요?

A. 새로운 호출스택을 생성해 쓰레드를 시작합니다.

Q. 데몬쓰레드란 뭔가요?

A. 보조 쓰레드입니다.

Q. join()메서드는 뭔가요?

A. 메인쓰레드가 다른 쓰레드의 작업이 끝날때까지 기다리게하는 메서드입니다.
   지정된 시간동안
*메인메서드가 끝나도 다른 쓰레드가 실행중이면 프로그램이 종료되지 않는다.

Q. Context Switing이 뭔가요?

A. 쓰레드에서 다른 쓰레드로 바뀔때를 의미합니다.

Q. i/o블락킹이란 뭔가요?

A. 싱글쓰레드일경우 입력을 기다리는동안 프로그램은 멈춰있다.

Q. 데몬쓰레드란 뭔가요?

A. 일반 쓰레드의 작업을 돕는 보조적인 역할을 합니다.
    일반 쓰레드가 모두 종료되면 자동적으로 종료 됩니다.
    ex(가비지컬렉터, 자동저장, 화면 자동갱신)
    무한루프와 조건문을 이용해서 실행 후 대기하다가 특정조건이 만족되면
    작업을 수행하고 다시 대기하도록 작성한다.
    start()를 호출하기 전에 setdemon이 실행되어야 함

sleep()쓰레드를 잠들게함(일시정지) 시간이 다되면 깸 1/1000분의 단위
join()다른 쓰레드 기다리기
interrupt() 쓰레드 깨우기 sleep()나 join()에의해 잠든것 깨우기
suspend()쓰레드 일시정지 resume()을 호출하면 다시 실행댜기상태가됨
yield()실행중에 자신에게 주어진 실행시간을 양보하고 자신은 실행대기 상태가 된다.

sleep나 yield는 static메서드 자기 자신에게만 적용됨

interrupt() 쓰레드의 interrupted상태를 false에서 true로 변경
isinterrupted() 쓰레드의 isinterrupted상태를 반환
interrupted() 현재 쓰레드의 interrupted상태를 알려주고 false로 초기화

Q. dead-lock이란 뭔가요?

A. 교착상태

Q. volatile란 뭔가요?

A. 쉽게 바뀌는 변수 cpu의 코어들이 메모리에 있는 값을 복사해 가지고 있는데 복사본을 사용하지 않고 메모리에 있는 원본을 사용

Q. yield()메서드란 뭔가요?

A. 남은 시간을 다음 쓰레드에게 양보하고 자신은 실행대기한다.

Q. 쓰레드의 동기화란 뭔가요?

A. 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하게 막는것

* 동기화 하려면 간섭받지 않아야 하는 문장들을 임계영역으로 설정
  임계영역은 락(lock)을 얻은 단 하나의 쓰레드만 출입가능(객체 1개에 락 1개)

Q. 불변객체란 뭔가요?

A. 객체 생성이후 내부의 상태가 변하지 않는 객체입니다.

객체인경우 참조변수를 final로 변경

배열인 경우 copy해서 저장하고 getter를 clone으로 반환합니다.

list인경우 새로운 list를 만들어 값을 복사해야 합니다 방어적 복사

thread-safety하여 병렬프로그래밍에 유용하며 동기화를 고려하지 않아도 된다.
가비지 컬렉션 성능을 높일 수 있다.

방어적복사 vs collections.unmodifiableList(); 중 적절히 사용

http 기본 요청 포트 80
https 기본 포트 요청 443
리액트는 3000실행 스프링부트는 8050실행
리액트는 npm run build를 통해 리액트의 정적 파일을 제공
nginx에서 실행하면 80번포트로 실행되는 리액트의 정적파일
그리고 sites-available 파일에 설정된 url:포트 로 요청을 보냄

- 웹 통신의 큰 흐름
Q. 주소창에 www.google.com 입력시 일어나는 일을 설명해 보세요.
A. 웹 브라우저(크롬 등)은 입력된 url에 상응하는 ip주소를 찾기 위해 DNS캐시 기록을 확인
DNS 캐시 기록에 없다면 ISP의 DNS서버에서 DNS QUERY를 통해 IP주소를 검색.
검색된 ip주소를 받은 브라우저는 3-way handshake를 실행
3-way handshake는 단순히 클라이언트와 서버가 연결이 가능한가를 확인하는 과정
얘를 들어 리소스가 없다해도 ex)www.google.com/ask.html 이라도 서버가 정상적이면 tcp연결은 확인 tcp포트는 80/443 가 열려있으므로
그 이후 리소스가 없다면 404에러를 반환 결국 404반환도 서버에서 보내주는 거니깐


Q. IP란? 
A. 인터넷 프로토콜

Q. DNS 캐시 란? 
A. 컴퓨터 OS에서 유지 관리하는 임시 데이터베이스로 최근 방문한 모든 기록과 웹 사이트 및 기타 도메인에 대한 방문 시도를 포함한 정보
즉 입력한 URL이 DNS캐시에 있으면 빠르게 가져와 연결 가능

Q. ISP란?
A. Internet service provider (skt, lg, kt 등등)
Q. ISP의 DNS서버란?
A. DNS와 매핑된 IP주소 정보가 저장된 일종의 데이터 베이스

